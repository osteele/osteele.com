<?php
// $Id: akismet.module,v 1.25 2006/06/20 15:16:44 markus_petrux Exp $

/**
 * Akismet Drupal and Module versions.
 */
define('AKISMET_DRUPAL_VERSION', '4.7');
define('AKISMET_MODULE_VERSION', '1.1.2');
define('AKISMET_MODULE_HOMEURL', 'http://www.phpmix.org/projects/drupal/4_7/akismet');
define('AKISMET_MODULE_USERAGENT', 'phpMiX.org | projects/drupal/4_7/akismet | '. AKISMET_MODULE_VERSION);


/**
 * Akismet API constants.
 */
define('AKISMET_API_HOST', 'rest.akismet.com');
define('AKISMET_API_PORT', 80);
define('AKISMET_API_VERSION', '1.1');
define('AKISMET_API_USERAGENT', 'Drupal/'. AKISMET_DRUPAL_VERSION .' | akismet.module/'. AKISMET_MODULE_VERSION);
define('AKISMET_API_RESULT_ERROR', -1);
define('AKISMET_API_RESULT_SUCCESS', 0);
define('AKISMET_API_RESULT_IS_SPAM', 1);
define('AKISMET_API_RESULT_IS_HAM', 2);


/**
 * Implementation of hook_help().
 */
function akismet_help($section) {
  $output = '';
  switch ($section) {
    case 'admin/modules#description':
      $output = t('Use <a href="%akismet">Akismet Service</a> to protect your site from being spammed.', array('%akismet' => 'http://akismet.com'));
      break;
    case 'admin/help#akismet':
      $output = t('<p>In order to use the <a href="%akismet">Akismet Service</a>, you need a <a href="%wpapikey">WordPress.com API key</a>. If you don\'t have one already, you can get it by simply signing up for a free account at <a href="%wordpress-com">wordpress.com</a>. Please, consult the <a href="%akismet-faq">Akismet FAQ</a> for further information.</p>
<p>The <em>akismet module</em> may automatically check for spam posted in content (nodes and/or comments) by any user, except node or comment administrators respectively. It is also possible, from the <a href="%access-control">access control</a> panel, to grant <em>%no-check-perm</em> permission to <em>user roles</em> of your choice.</p>
<p>Content marked as <em>spam</em> is still saved into database so it can be reviewed by content administrators. There is <a href="%akismet-settings">an option</a> that allows you to specify how long this information will be kept in the database. <em>Spam</em> older than a specified age will be automatically removed. Requires crontab.</p>
<p>Automatic spam detection can be enabled or disabled by content type and/or comments. In addition to this, the <em>akismet module</em> makes it easy for <em>content administrators</em> to manually <em>publish</em>/<em>unpublish</em> content and <em>mark</em>/<em>unmark</em> content as spam, from links available at the bottom of content.</p>
<p></p>',
        array(
          '%akismet' => 'http://akismet.com',
          '%wpapikey' => 'http://wordpress.com/api-keys/',
          '%wordpress-com' => 'http://wordpress.com',
          '%akismet-faq' => 'http://akismet.com/faq/',
          '%akismet-settings' => url('admin/settings/akismet'),
          '%access-control' => url('admin/access'),
          '%no-check-perm' => t('post with no akismet checking')
        ));
      break;
    case 'admin/help/akismet':
    case 'admin/settings/akismet':
      $output = t('<p>The <a href="%akismet-module-home">akismet module</a> for <a href="%drupal">Drupal</a> allows you to use the <a href="%akismet">Akismet Service</a> to protect your site from being spammed.</p>',
        array(
          '%akismet-module-home' => AKISMET_MODULE_HOMEURL,
          '%drupal' => 'http://drupal.org',
          '%akismet' => 'http://akismet.com'
        ));
        if ($section == 'admin/settings/akismet') {
          $output .= _akismet_get_version_message($section);
        }
    case 'admin/akismet':
      $output .= t('<p>Akismet has caught <strong>%count spam</strong> for you since <strong>%since</strong>.</p>', array('%count' => akismet_get_spam_counter(), '%since' => akismet_get_counting_since()));
      if ($section == 'admin/settings/akismet') {
        $output .= theme('more_help_link', url('admin/help/akismet'));
      }
      break;
    default:
      if (arg(0) == 'admin' && arg(1) == 'akismet' && !isset($_POST['edit'])) {
        if (arg(2) == 'nodes') {
          if (arg(3) == 'unpublished') {
            $output = t('Below is the list of <strong>unpublished nodes</strong> awaiting for moderation.');
          }
          else if (arg(3) == 'published') {
            $output = t('Below is the list of <strong>published nodes</strong>.');
          }
          else { // spam
            $output = t('Below is the list of <strong>nodes marked as spam</strong> awaiting for moderation.');
          }
          $output .= ' '. t('Click on the titles to see the content of the nodes or the author\'s name to view the author\'s user information. You may also wish to click on the headers to order the nodes upon your needs.');
        }
        else if (arg(2) == 'comments') {
          if (arg(3) == 'unpublished') {
            $output = t('Below is the list of <strong>unpublished comments</strong> awaiting for moderation.');
          }
          else if (arg(3) == 'published') {
            $output = t('Below is the list of <strong>published comments</strong>.');
          }
          else { // spam
            $output = t('Below is the list of <strong>comments marked as spam</strong> awaiting for moderation.');
          }
          $output .= ' '. t('Click on the subjects to see the comments or the author\'s name to view the author\'s user information. You may also wish to click on the headers to order the comments upon your needs.');
        }
        if (!empty($output)) {
          $output .= '<br />'. t('<strong>Note:</strong> To interact fully with the <a href="%akismet">Akismet Service</a> you really should try putting data back into the system as well as just taking it out. If it is at all possible, please use the submit <em>ham</em> operation rather than simply publishing content that was identified as spam (false positives). This is necessary in order to let Akismet learn from its mistakes. Thank you.', array('%akismet' => 'http://akismet.com'));
        }
      }
      break;
  }
  return $output;
}

/**
 * Implementation of hook_perm().
 */
function akismet_perm() {
  $perms = array();

  foreach (node_get_types() as $type => $name) {
    $perms[] = 'moderate spam in nodes of type '. $name;
  }
  $perms[] = 'moderate spam in comments';
  $perms[] = 'post with no akismet checking';

  return $perms;
}

/**
 * Implementation of hook_cron().
 */
function akismet_cron() {
  require_once('./'. drupal_get_path('module', 'akismet') . '/akismet_cron.inc');
  register_shutdown_function('akismet_cron_shutdown');
}

/**
 * Implementation of hook_settings().
 */
function akismet_settings() {
  require_once('./'. drupal_get_path('module', 'akismet') . '/akismet_admin.inc');
  return _akismet_settings_form();
}

/**
 * Implementation of hook_menu().
 */
function akismet_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    // Changes in content types force the menu to be rebuilt,
    // so it should be safe to cache this menu items here.
    // Users will only see this menu if they actually can
    // moderate, at least, one content type.
    $moderator_types = akismet_get_moderator_types();
    $moderator_types_count = count($moderator_types);
    if ($moderator_types_count > 0) {
      $items[] = array('path' => 'admin/akismet', 'title' => t('akismet moderation queue'),
        'callback' => 'akismet_callback_queue',
        'access' => ($moderator_types_count > 0 ? TRUE : FALSE));
      $items[] = array('path' => 'admin/akismet/overview', 'title' => t('overview'),
        'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => 0);
      if (!isset($moderator_types['comments']) || $moderator_types_count > 1) {
        $items[] = array('path' => 'admin/akismet/nodes', 'title' => t('nodes'),
          'type' => MENU_LOCAL_TASK, 'weight' => 1);
        $items[] = array('path' => 'admin/akismet/nodes/spam', 'title' => t('spam'),
          'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => 0);
        $items[] = array('path' => 'admin/akismet/nodes/unpublished', 'title' => t('unpublished nodes'),
          'type' => MENU_LOCAL_TASK, 'weight' => 1);
        $items[] = array('path' => 'admin/akismet/nodes/published', 'title' => t('published nodes'),
          'type' => MENU_LOCAL_TASK, 'weight' => 2);
      }
      if (isset($moderator_types['comments'])) {
        $items[] = array('path' => 'admin/akismet/comments', 'title' => t('comments'),
          'type' => MENU_LOCAL_TASK, 'weight' => 2);
        $items[] = array('path' => 'admin/akismet/comments/spam', 'title' => t('spam'),
          'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => 0);
        $items[] = array('path' => 'admin/akismet/comments/unpublished', 'title' => t('unpublished comments'),
          'type' => MENU_LOCAL_TASK, 'weight' => 1);
        $items[] = array('path' => 'admin/akismet/comments/published', 'title' => t('published comments'),
          'type' => MENU_LOCAL_TASK, 'weight' => 2);
      }
    }
  }
  else {
    // Paths may look like 'akismet/content_type/content_id/operation'
    if (arg(0) == 'akismet' && is_numeric(arg(2))) {
      $content_type = arg(1);
      if ($content_type == 'node' || ($content_type == 'comment' && module_exist('comment'))) {
        $op = arg(3);
        if ($op == 'publish' || $op == 'unpublish') {
          $callback = 'akismet_callback_set_published_status';
        }
        else if ($op == 'submit-spam' || $op == 'submit-ham') {
          $callback = 'akismet_callback_set_spam_status';
        }
        if (isset($callback)) {
          $moderator_type = akismet_content_get_moderator_type($content_type, arg(2));
          if (!empty($moderator_type)) {
            $items[] = array('path' => 'akismet', 'title' => t('switch content status'),
              'callback' => $callback,
              'access' => akismet_is_spam_moderator($moderator_type),
              'type' => MENU_CALLBACK);
          }
        }
      }
    }
    else {
      // Load the administration specific code?
      if (arg(0) == 'admin' && arg(1) == 'akismet') {
        require_once('./'. drupal_get_path('module', 'akismet') . '/akismet_admin.inc');
      }
    }
  }

  return $items;
}

/**
 * Implementation of hook_link().
 */
function akismet_link($type, $content = 0, $main = 0) {
  $links = array();
  if ($type == 'node' && akismet_is_spam_moderator($content->type)) {
    if (variable_get('akismet_node_publish_links', 0)) {
      if ($content->status) {
        $links[] = l(t('unpublish'), 'akismet/node/'. $content->nid .'/unpublish');
      }
      else {
        $links[] = l(t('publish'), 'akismet/node/'. $content->nid .'/publish');
      }
    }
    if (variable_get('akismet_node_spam_links', 0)) {
      if (akismet_content_is_spam('node', $content->nid)) {
        $links[] = l((variable_get('akismet_connection_enabled', 1) ? t('submit ham') : t('mark as ham')), 'akismet/node/'. $content->nid .'/submit-ham');
      }
      else {
        $links[] = l((variable_get('akismet_connection_enabled', 1) ? t('submit spam') : t('mark as spam')), 'akismet/node/'. $content->nid .'/submit-spam');
      }
    }
  }
  else if ($type == 'comment' && akismet_is_spam_moderator('comments')) {
    if (variable_get('akismet_comment_publish_links', 1)) {
      if ($content->status == COMMENT_PUBLISHED) {
        $links[] = l(t('unpublish'), 'akismet/comment/'. $content->cid .'/unpublish');
      }
      else if ($content->status == COMMENT_NOT_PUBLISHED) {
        $links[] = l(t('publish'), 'akismet/comment/'. $content->cid .'/publish');
      }
    }
    if (variable_get('akismet_comment_spam_links', 1)) {
      if (akismet_content_is_spam('comment', $content->cid)) {
        $links[] = l((variable_get('akismet_connection_enabled', 1) ? t('submit ham') : t('mark as ham')), 'akismet/comment/'. $content->cid .'/submit-ham');
      }
      else {
        $links[] = l((variable_get('akismet_connection_enabled', 1) ? t('submit spam') : t('mark as spam')), 'akismet/comment/'. $content->cid .'/submit-spam');
      }
    }
  }
  return $links;
}

/**
 * Menu callback; publish/unpublish content.
 *
 * @param string Content type; it can be 'node' or 'comment'.
 * @param integer Content ID; can be either a nid or a cid.
 * @param string Operation; it can be 'publish' or 'unpublish'.
 */
function akismet_callback_set_published_status($content_type, $content_id, $op) {
  // Load the content (existence has been checked in hook_menu).
  $content = akismet_content_load($content_type, $content_id);

  if ($content_type == 'node') {
    $is_published = ($content->status ? TRUE : FALSE);
  }
  else { // comment
    $is_published = ($content->status == COMMENT_PUBLISHED ? TRUE : FALSE);
  }

  if ($op == 'publish' && !$is_published) {
    akismet_content_publish_operation($content_type, $content, 'publish');
  }
  else if ($op == 'unpublish' && $is_published) {
    akismet_content_publish_operation($content_type, $content, 'unpublish');
  }

  if ($content_type == 'node') {
    drupal_goto('node/'. $content->nid);
  }
  else { // comment
    drupal_goto('node/'. $content->nid, NULL, 'comment-'. $content->cid);
  }
}

/**
 * Menu callback; mark/unmark content as spam.
 *
 * When content is marked as spam, it is also unpublished (if necessary) and vice-versa.
 *
 * @param string Content type; it can be 'node' or 'comment'.
 * @param integer Content ID; can be either a nid or a cid.
 * @param string Operation; it can be 'submit-spam' or 'submit-ham'.
 */
function akismet_callback_set_spam_status($content_type, $content_id, $op) {
  $is_spam = akismet_content_is_spam($content_type, $content_id);

  // Load the content (existence has been checked in hook_menu).
  $content = akismet_content_load($content_type, $content_id);

  if ($content_type == 'node') {
    $is_published = ($content->status ? TRUE : FALSE);
  }
  else { // comment
    $is_published = ($content->status == COMMENT_PUBLISHED ? TRUE : FALSE);
  }

  // insert or remove the spam marker (publishing/unpublishing if necessary).
  if ($op == 'submit-spam') {
    if (!$is_spam) {
      akismet_content_spam_operation($content_type, $content, 'submit-spam');
    }
    if ($is_published) {
      akismet_content_publish_operation($content_type, $content, 'unpublish');
    }
  }
  else if ($op == 'submit-ham') {
    if ($is_spam) {
      akismet_content_spam_operation($content_type, $content, 'submit-ham');
    }
    if (!$is_published) {
      akismet_content_publish_operation($content_type, $content, 'publish');
    }
  }

  if ($content_type == 'node') {
    drupal_goto('node/'. $content->nid);
  }
  else { // comment
    drupal_goto('node/'. $content->nid, NULL, 'comment-'. $content->cid);
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function akismet_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'insert':
    case 'update':
      // If Akismet connections are not enabled, we have nothing else to do here.
      if (!variable_get('akismet_connection_enabled', 1)) {
        akismet_notify_moderators('node', $node, ($node->status ? TRUE : FALSE), FALSE);
        break;
      }

      // Also quit asap, if current user has administration permission.
      if (akismet_is_spam_moderator($node->type)) {
        akismet_notify_moderators('node', $node, ($node->status ? TRUE : FALSE), FALSE);
        break;
      }

      // Now, check if it's about a node type that we have not been explicitly requested to check.
      $check_nodetypes = variable_get('akismet_check_nodetypes', NULL);
      if (!is_array($check_nodetypes) || !isset($check_nodetypes[$node->type]) || !$check_nodetypes[$node->type]) {
        akismet_notify_moderators('node', $node, ($node->status ? TRUE : FALSE), FALSE);
        break;
      }

      // Ok, let's send a query to Akismet.
      $akismet_api_result = akismet_api_cmd_comment_check(akismet_prepare_comment_data('node', $node));
      if ($akismet_api_result == AKISMET_API_RESULT_IS_HAM) {
        akismet_notify_moderators('node', $node, ($node->status ? TRUE : FALSE), FALSE);
      }
      else {
        if ($akismet_api_result == AKISMET_API_RESULT_IS_SPAM) {
          // Oops! Akismet is telling us we got spammed, let's mark the comment as such.
          akismet_content_spam_operation('node', $node, 'submit-spam', FALSE);
          // Increment Akismet spam counter
          variable_set('akismet_counter_spam', akismet_get_spam_counter() + 1);

          akismet_notify_moderators('node', $node, FALSE, TRUE);
        }
        else {
          akismet_notify_moderators('node', $node, FALSE, FALSE);
        }

        // Unpublish the node, if necessary.
        if ($node->status) {
          akismet_content_publish_operation('node', $node, 'unpublish', FALSE);
        }

        // Since users won't see their content published, show them a polite explanation on why.
        $content_type_name = node_get_name($node);
        drupal_set_message(t('Your %content-type-name has been queued for moderation by site administrators and will be published after approval.', array('%content-type-name' => $content_type_name)));

        // Record the event to watchdog.
        if ($akismet_api_result == AKISMET_API_RESULT_ERROR) {
          watchdog('content', t('Akismet service seems to be down, %content-type-name queued for manual approval: %title', array('%content-type-name' => $content_type_name, '%title' => theme('placeholder', $node->title))), WATCHDOG_WARNING, l(t('view'), 'node/'. $node->nid));
        }
        else {
          watchdog('content', t('Spam detected by Akismet in %content-type-name: %title', array('%content-type-name' => $content_type_name, '%title' => theme('placeholder', $node->title))), WATCHDOG_WARNING, l(t('view'), 'node/'. $node->nid));
          // If requested to, generate a delay so the spammer has to wait for a while.
          if (($seconds = variable_get('akismet_antispambot_delay', 60)) > 0) {
            sleep($seconds);
          }
        }
      }
      break;
    case 'delete':
      db_query('DELETE FROM {akismet_spam_marks} WHERE content_type = \'node\' AND content_id = %d', $node->nid);
      break;
  }
}

/**
 * Implementation of hook_comment().
 */
function akismet_comment(&$comment, $op) {
  switch ($op) {
    case 'insert':
    case 'update':
      if (!variable_get('akismet_check_comments', 0) || akismet_is_spam_moderator('comments') || !variable_get('akismet_connection_enabled', 1)) {
        akismet_notify_moderators('comment', $comment, ($comment->status == COMMENT_PUBLISHED ? TRUE : FALSE), FALSE);
      }
      break;
    case 'delete':
      db_query('DELETE FROM {akismet_spam_marks} WHERE content_type = \'comment\' AND content_id = %d', $comment->cid);
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 */
function akismet_form_alter($form_id, &$form) {
  // Hook into comment edit/reply form.
  if ($form_id == 'comment_form' && variable_get('akismet_check_comments', 1)) {
    // ...only if current user is not moderator.
    if (!akismet_is_spam_moderator('comments')) {
      // ...also check if Akismet connections are enabled.
      if (variable_get('akismet_connection_enabled', 1)) {
        if (isset($form['cid']) && isset($form['cid']['#value']) && is_numeric($form['cid']['#value'])) {
          // This is the simple hook method, we already have the $cid.
          $form['#submit']['_akismet_comment_form_submit'] = array();
        }
        else {
          // This is a bit more complex, because the user is creating a new comment, so
          // how can we get the $cid? See comments below, within our own submit callback.
          $form['#submit'] = array('_akismet_comment_form_submit' => array($form['#submit']));
        }
      }
      // Inject anti-spambot code, if requested to.
      if (akismet_is_anti_spambot_enabled()) {
        $form['#validate']['_akismet_comment_form_validate'] = array();
      }
    }
  }
  // Hook into node edit form.
  else if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {
    // ...only if current user is not moderator.
    if (!akismet_is_spam_moderator('comments')) {
      // ...also check if it's about a node type that we have been explicitly requested to check.
      $check_nodetypes = variable_get('akismet_check_nodetypes', NULL);
      $node_type = $form['type']['#value'];
      if (is_array($check_nodetypes) && isset($check_nodetypes[$node_type]) && $check_nodetypes[$node_type]) {
        // Inject anti-spambot code, if requested to.
        if (akismet_is_anti_spambot_enabled()) {
          $form['#validate']['_akismet_node_form_validate'] = array();
        }
      }
    }
  }
}

/**
 * Node form validate callback; check for spambots.
 */
function _akismet_node_form_validate($form_id, $form_values) {
  // Quit if there have already been errors in the form.
  if (form_get_errors()) {
    return;
  }

  // Ok, let's build a quick query to see if we can catch a spambot.
  global $user;
  $antispambot_rules = akismet_get_anti_spambot_rules();
  $sql_where = array();
  $sql_args = array();
  if ($antispambot_rules['ip']) {
    $sql_where[] = 's.hostname = \'%s\'';
    $sql_args[] = $_SERVER['REMOTE_ADDR'];
  }
  if ($antispambot_rules['body'] && !empty($form_values['body'])) {
    $sql_where[] = 'n.body = \'%s\'';
    $sql_args[] = $form_values['body'];
  }
  if ($antispambot_rules['mail'] && !empty($user->mail)) {
    $sql_where[] = 's.mail = \'%s\'';
    $sql_args[] = $user->mail;
  }

  if (count($sql_where) > 0) {
    if ($antispambot_rules['body'] || $antispambot_rules['mail']) {
      $sql_stmt = 'SELECT 1 FROM {node} n INNER JOIN {node_revisions} r ON r.nid = n.nid INNER JOIN {akismet_spam_marks} s ON s.content_type = \'node\' AND s.content_id = n.nid WHERE (%cond)';
    }
    else {
      $sql_stmt = 'SELECT 1 FROM {akismet_spam_marks} s WHERE s.content_type = \'node\' AND (%cond)';
    }
    $sql_stmt = str_replace('%cond', implode(' OR ', $sql_where), $sql_stmt);
    if (db_result(db_query($sql_stmt, $sql_args, 0, 1))) {
      akismet_anti_spambot_action(array(
        t('SQL') => _akismet_translate_query($sql_stmt, $sql_args),
        t('E-mail') => (isset($user->mail) ? $user->mail : ''),
        t('Body') => $form_values['body']
      ));
    }
  }
}

/**
 * Comment form validate callback; check for spambots.
 */
function _akismet_comment_form_validate($form_id, $form_values) {
  // Quit if there have already been errors in the form.
  if (form_get_errors()) {
    return;
  }

  // Ok, let's build a quick query to see if we can catch a spambot.
  $antispambot_rules = akismet_get_anti_spambot_rules();
  $sql_where = array();
  $sql_args = array();
  if ($antispambot_rules['ip']) {
    $sql_where[] = 's.hostname = \'%s\'';
    $sql_args[] = $_SERVER['REMOTE_ADDR'];
  }
  if ($antispambot_rules['body'] && !empty($form_values['comment'])) {
    $sql_where[] = 'c.comment = \'%s\'';
    $sql_args[] = $form_values['comment'];
  }
  if ($antispambot_rules['mail'] && !empty($form_values['mail'])) {
    $sql_where[] = 's.mail = \'%s\'';
    $sql_args[] = $form_values['mail'];
  }

  if (count($sql_where) > 0) {
    if ($antispambot_rules['body'] || $antispambot_rules['mail']) {
      $sql_stmt = 'SELECT 1 FROM {comments} c INNER JOIN {akismet_spam_marks} s ON s.content_type = \'comment\' AND s.content_id = c.cid WHERE (%cond)';
    }
    else {
      $sql_stmt = 'SELECT 1 FROM {akismet_spam_marks} s WHERE s.content_type = \'comment\' AND (%cond)';
    }
    $sql_stmt = str_replace('%cond', implode(' OR ', $sql_where), $sql_stmt);
    if (db_result(db_query($sql_stmt, $sql_args, 0, 1))) {
      akismet_anti_spambot_action(array(
        t('SQL') => _akismet_translate_query($sql_stmt, $sql_args),
        t('E-mail') => $form_values['mail'],
        t('Comment') => $form_values['comment']
      ));
    }
  }
}

/**
 * Comment form submit callback; check for spam.
 */
function _akismet_comment_form_submit($form_id, $form_values, $original_submit_callback = NULL) {
  // Our default destination. It doesn't need to override the original.
  $goto = NULL;

  // If the comment is being edited, then there's no problem to get the $cid.
  // In this case, the original #submit callback has already been called.
  if (isset($form_values['cid'])) {
    $cid = $form_values['cid'];
  }
  // However, if the comment is being created, we'll try to get the $cid from the
  // return value of the original #submit callback. It's an array that customizes
  // the URL the user should be sent when the form is submitted. It contains the
  // $cid in the last argument, in the form of "comment-$cid", the hash of the URL.
  else {
    // Invoke the previous submit callbacks and capture their return values to try
    // to get the $cid from there.

    // The first critical part with this approach is that we have to emmulate the
    // $form argument that form.inc::drupal_submit_form() expects. At this point in
    // time, this function just uses the '#submit' element, but that could change in
    // the future. We have to keep an eye here, or think about a completely different
    // approach. Hopefully, this one will remain stable during the 4.x lifecycle.
    $form = array('#submit' => $original_submit_callback);

    // The second critical part is that we expect to find the $cid in the 3rd element
    // of the $goto array, as described above.
    $goto = drupal_submit_form($form_id, $form);
    if (is_array($goto) && isset($goto[2]) && preg_match('#^comment-([0-9]+)$#', $goto[2], $match)) {
      $cid = $match[1];
    }
  }

  // Once we have a $cid, we can (try to) load the comment with all relevant
  // information that we need to make the Akismet request to check for spam.
  if ($cid) {
    $comment = akismet_content_load('comment', $cid);
    // If we got a comment, send query to Akismet.
    if ($comment) {
      $akismet_api_result = akismet_api_cmd_comment_check(akismet_prepare_comment_data('comment', $comment));
      if ($akismet_api_result == AKISMET_API_RESULT_IS_HAM) {
        akismet_notify_moderators('comment', $comment, ($comment->status == COMMENT_PUBLISHED ? TRUE : FALSE), FALSE);
      }
      else {
        if ($akismet_api_result == AKISMET_API_RESULT_IS_SPAM) {
          // Oops! Akismet is telling us we got spammed, let's mark the comment as such.
          akismet_content_spam_operation('comment', $comment, 'submit-spam', FALSE);
          // Increment Akismet spam counter
          variable_set('akismet_counter_spam', akismet_get_spam_counter() + 1);

          akismet_notify_moderators('comment', $comment, FALSE, TRUE);
        }
        else {
          akismet_notify_moderators('comment', $comment, FALSE, FALSE);
        }

        // Unpublish the comment, if necessary.
        if ($comment->status == COMMENT_PUBLISHED) {
          akismet_content_publish_operation('comment', $comment, 'unpublish', FALSE);
        }

        // Since users won't see their replies published, show them a polite explanation on why.
        drupal_set_message(t('Your comment has been queued for moderation by site administrators and will be published after approval.'));

        // Record the event to watchdog.
        if ($akismet_api_result == AKISMET_API_RESULT_ERROR) {
          watchdog('content', t('Akismet service seems to be down, comment queued for manual approval: %subject', array('%subject' => theme('placeholder', $comment->subject))), WATCHDOG_WARNING, l(t('view'), 'node/'. $comment->nid, NULL, NULL, 'comment-'. $comment->cid));
        }
        else {
          watchdog('content', t('Spam detected by Akismet in comment: %subject', array('%subject' => theme('placeholder', $comment->subject))), WATCHDOG_WARNING, l(t('view'), 'node/'. $comment->nid, NULL, NULL, 'comment-'. $comment->cid));
          // If requested to, generate a delay so the spammer has to wait for a while.
          if (($seconds = variable_get('akismet_antispambot_delay', 60)) > 0) {
            sleep($seconds);
          }
        }
      }
    }
  }

  // Return NULL or the destination returned by the original #submit callback.
  return $goto;
}

/**
 * Get anti-spambot rules.
 *
 * @return array
 */
function akismet_get_anti_spambot_rules() {
  static $antispambot_rules = FALSE;
  if (!$antispambot_rules) {
    $antispambot_rules = array();
    $options = variable_get('akismet_antispambot_rules', NULL);
    if (is_array($options)) {
      foreach ($options as $key => $value) {
        if (is_string($key)) {
          $antispambot_rules[$key] = ($key === $value ? TRUE : FALSE);
        }
      }
    }
  }
  return $antispambot_rules;
}

/**
 * Check if anti-spambot options are enabled.
 *
 * @return boolean TRUE if enabled; FALSE otherwise.
 */
function akismet_is_anti_spambot_enabled() {
  $antispambot_rules = akismet_get_anti_spambot_rules();
  return (count($antispambot_rules) > 0 ? TRUE : FALSE);
}

/**
 * Perform an anti-spambot action based on module settings.
 *
 * @param array Extra data, used here to enhance the logged information, for debugging purposes.
 */
function akismet_anti_spambot_action($debug_info) {
  $antispambot_action = variable_get('akismet_antispambot_action', '503');

  // First action is generate a delay, if requested to.
  if (($seconds = variable_get('akismet_antispambot_delay', 60)) > 0) {
    sleep($seconds);
  }

  // If no other action was set, we're done.
  if ($antispambot_action == 'none') {
    return;
  }

  $items = array();
  foreach ($debug_info as $label => $value) {
    $items[] = '<strong>'. check_plain($label) .'</strong>: '. check_plain($value);
  }

  // From here on, the request is killed using different methods.
  if ($antispambot_action == '403d') {
    drupal_access_denied();
    $message = t('Spambot detected (action: 403 Forbidden).');
  }
  else if ($antispambot_action == '403') {
    @header('HTTP/1.0 403 Forbidden');
    print t('Access denied');
    $message = t('Spambot detected (action: 403 Forbidden).');
  }
  else { // 503
    @header('HTTP/1.0 503 Service unavailable');
    print t('Service unavailable');
    $message = t('Spambot detected (action: 503 Service unavailable).');
  }

  watchdog('akismet', $message .'<p>'. t('Additional information:') .'</p>'. theme('item_list', $items));

  module_invoke_all('exit');
  exit;
}

/**
 * Expand query for debugging purposes.
 *
 * @param string SQL statement.
 * @param mixed array or variable list of arguments.
 */
function _akismet_translate_query($query) {
  $args = func_get_args();
  array_shift($args);
  $query = db_prefix_tables($query);
  if (isset($args[0]) && is_array($args[0])) { // 'All arguments in one array' syntax
    $args = $args[0];
  }
  _db_query_callback($args, TRUE);
  $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
  return $query;
}

/**
 * Check if specified content is marked as spam.
 *
 * @param string Content type; can be either 'node' or 'comment'.
 * @param integer Content ID; can be either a nid or a cid.
 * @return boolean TRUE if content is marked as spam; FALSE otherwise.
 */
function akismet_content_is_spam($content_type, $content_id) {
  return db_result(db_query('SELECT 1 FROM {akismet_spam_marks} WHERE content_type = \'%s\' AND content_id = %d', $content_type, $content_id));
}

/**
 * Get moderator type required for specified content.
 *
 * @param string Content type; can be either 'node' or 'comment'.
 * @param integer Content ID; can be either a nid or a cid.
 * @return string Moderator Type or empty string if content is not found.
 */
function akismet_content_get_moderator_type($content_type, $content_id) {
  if ($content_type == 'node') {
    $moderator_type = db_result(db_query('SELECT type FROM {node} WHERE nid = %d', $content_id));
    if (!$moderator_type) {
      $moderator_type = '';
    }
  }
  else if ($content_type == 'comment') {
    $moderator_type = (db_result(db_query('SELECT 1 FROM {comments} WHERE cid = %d', $content_id)) ? 'comments' : '');
  }
  else {
    $moderator_type = '';
  }
  return $moderator_type;
}

/**
 * Get the types the current user is allowed to moderate.
 *
 * @param object The account to check; use current user if not given.
 * @return array Moderator Types.
 */
function akismet_get_moderator_types($account = NULL) {
  global $user;
  static $node_types = FALSE;
  static $moderator_types = array();

  if (is_null($account)) {
    $account = $user;
  }

  if ($node_types === FALSE) {
    $node_types = node_get_types();
  }

  if (!isset($moderator_types[$account->uid])) {
    if (user_access('administer nodes', $account)) {
      foreach ($node_types as $type => $name) {
        $moderator_types[$account->uid][$type] = $name;
      }
    }
    else {
      foreach ($node_types as $type => $name) {
        if (user_access('moderate spam in nodes of type '. $node_types[$type], $account)) {
          $moderator_types[$account->uid][$type] = $name;
        }
      }
    }

    if (user_access('administer comments', $account) || user_access('moderate spam in comments', $account)) {
      $moderator_types[$account->uid]['comments'] = t('comments');
    }
  }

  return $moderator_types[$account->uid];
}

/**
 * Is current user spam moderator?
 *
 * @param string Moderator Type (comments, node type or NULL).
 * @param object The account to check; use current user if not given.
 * @return boolean TRUE if current user is moderator of specified type; FALSE otherwise.
 */
function akismet_is_spam_moderator($moderator_type = NULL, $account = NULL) {
  global $user;
  if (is_null($account)) {
    $account = $user;
  }
  $moderator_types = akismet_get_moderator_types($account);
  if (is_null($moderator_type)) {
    return (count($moderator_types) > 0 ? TRUE : FALSE);
  }
  return isset($moderator_types[$moderator_type]);
}

/**
 * Notify moderators of new/updated content, only content needing approval or nothing at all.
 *
 * @param string Content type; can be either 'node' or 'comment'.
 * @param object Content object.
 * @param boolean TRUE if content is in published status.
 * @param boolean TRUE if content has been marked as spam.
 */
function akismet_notify_moderators($content_type, $content, $is_published, $is_spam) {
  global $user, $base_url;

  // Proceed only if e-mail notifications are enabled.
  if (!variable_get('akismet_email_enabled', 0)) {
    return;
  }

  // Make sure we have an object.
  $content = (object)$content;

  // Compute the related moderator permission.
  if ($content_type == 'comment') {
    $moderator_permission = 'moderate spam in comments';
    $administer_permission = 'administer comments';
  }
  else {
    $moderator_types = akismet_get_moderator_types($account);
    $moderator_permission = 'moderate spam in nodes of type '. $moderator_types[$content->type];
    $administer_permission = 'administer nodes';
  }

  // Obtain list of moderators of the specified content type.
  $sql = 'SELECT u.uid, u.name, u.mail, m.email_for'.
          ' FROM {permission} p'.
         ' INNER JOIN {users_roles} r ON r.rid = p.rid'.
         ' INNER JOIN {users} u ON u.uid = r.uid OR u.uid = 1'.
          ' LEFT JOIN {akismet_moderator} m ON m.uid = u.uid'.
         ' WHERE p.perm LIKE \'%%%s%%\''.
            ' OR p.perm LIKE \'%%%s%%\'';
  $result = db_query($sql, $moderator_permission, $administer_permission);
  $moderators = array();
  while ($u = db_fetch_object($result)) {
    if ($u->uid != $user->uid) {
      $moderators[$u->uid] = array(
        'name' => $u->name,
        'email_to' => $u->mail,
        'email_for' => (!is_null($u->email_for) ? $u->email_for : 'approval')
      );
    }
  }

  // Extract unique email addresses and ignore those who have requested to not get e-mail notifications.
  $unique_emails = array();
  foreach ($moderators as $uid => $moderator) {
    if ($moderator['email_for'] == 'all' || ($moderator['email_for'] == 'approval' && !$is_published)) {
      if (!isset($unique_emails[$moderator['email_to']])) {
        $unique_emails[$moderator['email_to']] = $uid;
      }
    }
  }
  if (count($unique_emails) <= 0) {
    return;
  }

  // If this is about a comment, try to load the node.
  // Also, prepare arguments for notification message.
  $site_name = variable_get('site_name', t('Drupal'));
  if ($content_type == 'comment') {
    if (!($node = akismet_content_load('node', $content->nid))) {
      watchdog('akismet', t('An error has ocurred while trying to notify moderators about a comment. The associated node could not be loaded.'), WATCHDOG_NOTICE, l(t('view'), 'node/'. $content->nid, NULL, NULL, 'comment-'. $content->cid));
      return;
    }
    $message_args = array(
      '%title-label' => t('Subject'),
      '%content-title' => check_plain($content->subject),
      '%content-type' => t('comment'),
      '%content-link' => url('node/'. $content->nid, NULL, 'comment-'. $content->cid, TRUE)
    );
    $message_title = t('[%site-name] moderator notification - Posted comment on \'%title\'', array('%site-name' => $site_name, '%title' => check_plain($node->title)));
  }
  else {
    $message_args = array(
      '%title-label' => t('Title'),
      '%content-title' => check_plain($content->title),
      '%content-type' => check_plain($moderator_types[$content->type]),
      '%content-link' => url('node/'. $content->nid, NULL, NULL, TRUE)
    );
    $message_title = t('[%site-name] moderator notification - Posted %type \'%title\'', array('%site-name' => $site_name, '%type' => check_plain($moderator_types[$content->type]), '%title' => check_plain($content->title)));
  }
  $message_args['%content-status'] = ($is_published ? t('published') : t('published')) . ($is_spam ? ' ('. t('marked as spam') .')' : '');
  $message_args['%site-name'] = check_plain($site_name);
  $message_args['%site-link'] = $base_url . base_path();

  $message_body = t(<<<EOT
Hello %user-name,

You can use the following information to review this %content-type:

%title-label: %content-title
URL: %content-link
Status: %content-status

Please, do not reply to this e-mail. It is an automated notification you are receiving because you are a moderator at %site-name. If you no longer wish to receive such notifications, you can change your moderator settings in your user profile.

Thank you

%site-link
EOT
  , $message_args);

  // Log the notification to watchdog.
  watchdog('akismet', t('Trying to notify the following recipients: %emails', array('%emails' => implode(', ', array_keys($unique_emails)))));

  // Send e-mails.
  $site_mail = variable_get('site_mail', ini_get('sendmail_from'));
  $headers = "From: $site_mail\nReply-to: $site_mail\nX-Mailer: Drupal\nReturn-path: $site_mail\nErrors-to: $site_mail";
  foreach ($unique_emails as $email_to => $uid) {
    user_mail(
      $email_to,
      $message_title,
      str_replace('%user-name', check_plain($moderators[$uid]['name']), $message_body),
      $headers
    );
  }
}

/**
 * Implementation of hook_user().
 */
function akismet_user($op, &$edit, &$account, $category = NULL) {
  $moderator_email_for_options = array(
    'all' => t('All new (or updated) content'),
    'approval' => t('Only content needing approval'),
    'never' => t('Never')
  );
  switch ($op) {
    case 'form':
      if ($category == 'account' && variable_get('akismet_email_enabled', 1)) {
        $moderator_types = akismet_get_moderator_types($account);
        $moderator_types_count = count($moderator_types);
        if ($moderator_types_count > 0) {
          $form = array();
          $form['akismet_moderator'] = array(
            '#type' => 'fieldset', '#title' => t('Akismet moderator settings'),
            '#weight' => 5,
            '#collapsible' => TRUE, '#collapsed' => FALSE,
            '#description' => t('You are currently moderator for the following content types: %types.', array('%types' => implode(', ', $moderator_types)))
          );
          $form['akismet_moderator']['akismet_moderator_email_for'] = array(
            '#type' => 'radios', '#title' => t('Send me e-mails for'),
            '#options' => $moderator_email_for_options,
            '#default_value' => (isset($moderator_email_for_options[$edit['akismet_moderator_email_for']]) ? $edit['akismet_moderator_email_for'] : 'approval')
          );
          return $form;
        }
      }
      break;
    case 'load':
      $moderator_types = akismet_get_moderator_types($account);
      $moderator_types_count = count($moderator_types);
      if ($moderator_types_count > 0) {
        $moderator_data = db_fetch_object(db_query('SELECT * FROM {akismet_moderator} WHERE uid = %d', $account->uid));
        $account->akismet_moderator_email_for = (isset($moderator_data->email_for) && isset($moderator_email_for_options[$moderator_data->email_for]) ? $moderator_data->email_for : 'approval');
      }
      break;
    case 'insert':
    case 'update':
      $moderator_types = akismet_get_moderator_types($account);
      $moderator_types_count = count($moderator_types);
      if ($moderator_types_count > 0 && isset($edit['akismet_moderator_email_for'])) {
        if (!isset($moderator_email_for_options[$edit['akismet_moderator_email_for']])) {
          $edit['akismet_moderator_email_for'] = 'approval';
        }
        db_query('UPDATE {akismet_moderator} SET email_for = \'%s\' WHERE uid = %d', $edit['akismet_moderator_email_for'], $account->uid);
        if (!db_affected_rows()) {
          db_query('INSERT INTO {akismet_moderator} (uid, email_for) VALUES (%d, \'%s\')', $account->uid, $edit['akismet_moderator_email_for']);
        }
        $edit['akismet_moderator_email_for'] = NULL;
        break;
      }
      // Fall through, to remove possible garbage.
    case 'delete':
      db_query('DELETE FROM {akismet_moderator} WHERE uid = %d', $account->uid);
      break;
  }
}

/**
 * Get the current akismet spam counter.
 *
 * @return integer
 */
function akismet_get_spam_counter() {
  return (int)variable_get('akismet_counter_spam', 0);
}

/**
 * Format the 'Counting since' date.
 *
 * @return string Counting since date formatted according to module settings.
 */
function akismet_get_counting_since() {
  $since = variable_get('akismet_counter_since', array('day' => date('j'), 'month' => date('n'), 'year' => date('Y')));
  $format = variable_get('akismet_counter_date_format', 'F j, Y');
  $replace = array(
    'd' => sprintf('%02d', $since['day']),
    'j' => $since['day'],
    'm' => sprintf('%02d', $since['month']),
    'M' => format_date(gmmktime(0, 0, 0, $since['month'], 2, 1970), 'custom', 'M', 0),
    'F' => format_date(gmmktime(0, 0, 0, $since['month'], 2, 1970), 'custom', 'F', 0),
    'Y' => $since['year']
  );
  return strtr($format, $replace);
}

/**
 * Implementation of hook_block().
 */
function akismet_block($op = 'list', $delta = 0, $edit = array()) {
  static $block_fields = FALSE;
  if (!$block_fields) {
    $block_fields = array(
      'type' => array(
        '#type' => 'radios',
        '#title' => t('Display counter as'),
        '#options' => array('image' => t('Image'), 'text' => t('Text')),
        '#default_value' => 'image'
      ),
      'sitename' => array(
        '#type' => 'radios',
        '#title' => t('Show site name'),
        '#options' => array('1' => t('Enabled'), '0' => t('Disabled')),
        '#default_value' => '1'
      ),
      'newwin' => array(
        '#type' => 'radios',
        '#title' => t('Open Akismet link in new window'),
        '#options' => array('1' => t('Enabled'), '0' => t('Disabled')),
        '#default_value' => '1'
      )
    );
  }
  switch ($op) {
    case 'list':
      $blocks_counter = variable_get('akismet_blocks_counter', 1);
      $blocks = array();
      for ($i = 0; $i < $blocks_counter; $i++) {
        $blocks[] = array('info' => t('Akismet spam counter (block:%count)', array('%count' => ($i+1))));
      }
      return $blocks;

    case 'configure':
      if ($delta < 0 || $delta >= variable_get('akismet_blocks_counter', 1)) {
        drupal_set_message(t('Oops! You are requesting a non-existing block, changes will not be saved.'), 'error');
        break;
      }
      $form = array();
      $form['description'] = array(
        '#type' => 'markup',
        '#value' => '<div class="description"><p>'. t('These options allow to customize the look of this <em>akismet spam counter</em> block.') .'</p></div>'
      );
      $block_settings = variable_get('akismet_blocks_'. $delta, FALSE);
      foreach ($block_fields as $field_key => $field_info) {
        $field_name = 'akismet_blocks_'. $delta .'_'. $field_key;
        $form[$field_name] = array();
        foreach ($field_info as $key => $value) {
          $form[$field_name][$key] = $value;
        }
        if ($block_settings && isset($block_settings[$field_key])) {
          $form[$field_name]['#default_value'] = $block_settings[$field_key];
        }
      }
      return $form;

    case 'save':
      if ($delta < 0 || $delta >= variable_get('akismet_blocks_counter', 1)) {
        drupal_set_message(t('Oops! You have requested a non-existing block, changes were not saved.'), 'error');
        break;
      }
      $block_settings = array();
      foreach ($block_fields as $field_key => $field_info) {
        $field_name = 'akismet_blocks_'. $delta .'_'. $field_key;
        $block_settings[$field_key] = $edit[$field_name];
      }
      variable_set('akismet_blocks_'. $delta, $block_settings);
      break;

    case 'view':
      if ($delta >= 0 && $delta < variable_get('akismet_blocks_counter', 1)) {
        $block_settings = variable_get('akismet_blocks_'. $delta, FALSE);
        if (!$block_settings) {
          $block_settings = array();
        }

        $block_args = array(
          'content' => '', // Built below.
          'counter' => akismet_get_spam_counter(),
          'since'   => akismet_get_counting_since(),
          'text'    => '', // Built below.
          'image'   => '', // Built below.
          'block'   => array('delta' => $delta) // completed below with current block settings.
        );

        foreach ($block_fields as $field_key => $field_info) {
          if (!isset($block_settings[$field_key])) {
            $block_settings[$field_key] = $field_info['#default_value'];
          }
          $block_args['block'][$field_key] = $block_settings[$field_key];
        }

        $target = ($block_settings['newwin'] ? ' target="_blank"' : '');
        $block_args['text'] = array(
          'plain' => array(
            'short' => check_plain(t('Proudly protected by Akismet, %count spam caught since %since.', array('%site_name' => variable_get('site_name', 'drupal'), '%count' => $block_args['counter'], '%since' => $block_args['since']))),
            'long'  => check_plain(t('%site_name is proudly protected by Akismet, %count spam caught since %since.', array('%site_name' => variable_get('site_name', 'drupal'), '%count' => $block_args['counter'], '%since' => $block_args['since'])))
          ),
          'html' => array(
            'short' => t('Proudly protected by <a href="%akismet"%target>Akismet</a>, %count spam caught since %since', array('%site_name' => variable_get('site_name', 'drupal'), '%akismet' => 'http://akismet.com', '%target' => $target, '%count' => $block_args['counter'], '%since' => $block_args['since'])),
            'long'  => t('%site_name is proudly protected by <a href="%akismet"%target>Akismet</a>, %count spam caught since %since', array('%site_name' => variable_get('site_name', 'drupal'), '%akismet' => 'http://akismet.com', '%target' => $target, '%count' => $block_args['counter'], '%since' => $block_args['since']))
          )
        );
        $text_version = ($block_settings['sitename'] ? 'long' : 'short');
        $title_text = $block_args['text']['plain'][$text_version];
        $image_url = base_path() . drupal_get_path('module', 'akismet') .'/akismet.gif';
        $block_args['image'] = '<img src="'. $image_url .'" title="'. $title_text .'" alt="'. $title_text .'" />';

        if ($block_settings['type'] == 'image') {
          $block_args['content'] = '<a href="http://akismet.com" title="'. $title_text .'"'. $target .'>'. $block_args['image'] .'</a>';
        }
        else {
          $block_args['content'] = $block_args['text']['html'][$text_version];
        }

        $block = array();
        $block['subject'] = t('Akismet spam counter');
        $block['content'] = theme('akismet_counter_block', $block_args);
        return $block;
      }
      break;
  }
}

/**
 * Allow themes customize the content of the akismet spam counter block.
 *
 * @param array arguments where each element is:
 *              content: String; the completely built block content.
 *              counter: Integer; the current spam counter.
 *              since  : String; the formatted 'counting since' date.
 *              text   : Array; with 2 subarrays defined as follows:
 *                       plain: Array with 2 elements ('short' and 'long').
 *                       html : Array with 2 elements ('short' and 'long').
 *              image  : String; the completely built IMG tag.
 *              block  : Array; Block settings.
 * @return string The content of the block.
 */
function theme_akismet_counter_block($args) {
  return $args['content'];
}

/**
 * Load a node or a comment.
 *
 * @param string Content type; can be either 'node' or 'comment'.
 * @param integer Content ID; can be either a nid or a cid.
 * @return mixed An object with requested content; FALSE on failure.
 */
function akismet_content_load($content_type, $content_id) {
  if ($content_type == 'node') {
    $content = node_load($content_id);
    if (empty($content->nid)) {
      $content = FALSE;
    }
  }
  else if ($content_type == 'comment') {
    $content = db_fetch_object(db_query(db_rewrite_sql('SELECT c.*, u.name AS registered_name FROM {comments} c INNER JOIN {users} u ON u.uid = c.uid WHERE c.cid = %d', 'c'), $content_id));
    if (empty($content->cid)) {
      $content = FALSE;
    }
    else if ($content->uid) {
      $content->name = $content->registered_name;
    }
  }
  else {
    $content = FALSE;
  }
  return $content;
}

/**
 * Delete a node or a comment.
 *
 * @param string Content type; can be either 'node' or 'comment'.
 * @param integer Content ID; can be either a nid or a cid.
 * @return boolean TRUE if specified was there; FALSE otherwise.
 */
function akismet_content_delete($content_type, $content_id) {
  if ($content_type == 'node') {
    $node = akismet_content_load($content_type, $content_id);
    if ($node) {
      // Sadly, we cannot invoke node_delete() because it checks for the
      // user to have delete permission on nodes, and this function may
      // be invoked from a cron task, which is run as anonymous user, so
      // we have to hardcode the low level parts here.

      // Code based on node.module::node_delete().

      db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);
      db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);

      // Call the node-specific callback (if any):
      node_invoke($node, 'delete');
      node_invoke_nodeapi($node, 'delete');

      // Remove this node from the search index if needed.
      if (function_exists('search_wipe')) {
        search_wipe($node->nid, 'node');
      }

      // Record the event to watchdog.
      watchdog('content', t('%type: deleted %title.', array('%type' => theme('placeholder', t($node->type)), '%title' => theme('placeholder', $node->title))));
      return TRUE;
    }
  }
  else if ($content_type == 'comment') {
    $comment = akismet_content_load($content_type, $content_id);
    if ($comment) {
      _comment_delete_thread($comment);
      _comment_update_node_statistics($comment->cid);
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Clear Drupal cache.
 *
 * This function needs to be called so anonymous users get updated content
 * when certain operations have been executed.
 */
function akismet_clear_cache() {
  static $already_done = FALSE;
  if (!$already_done) {
    cache_clear_all();
    $already_done = TRUE;
  }
}

/**
 * Mark content as spam or remove the mark.
 *
 * @param string Content type; can be either 'node' or 'comment'.
 * @param object Content object.
 * @param string Operation; it can be 'submit-spam' or 'submit-ham'.
 * @param boolean TRUE to log action (default); FALSE otherwise (ie. the caller logs the action).
 */
function akismet_content_spam_operation($content_type, $content, $op, $log_action = TRUE) {
  if ($content_type == 'node') {
    global $user;
    $content_id = $content->nid;
    $content_title = $content->title;
    $content_link = l(t('view'), 'node/'. $content->nid);
    $user_mail = (isset($user->mail) ? $user->mail : '');
  }
  else { // comment
    $content_id = $content->cid;
    $content_title = $content->subject;
    $content_link = l(t('view'), 'node/'. $content->nid, NULL, NULL, 'comment-'. $content->cid);
    $user_mail = $content->mail;
  }

  if ($op == 'submit-spam') {
    $hostname = (!empty($content->hostname) ? $content->hostname : $_SERVER['REMOTE_ADDR']);
    db_query('INSERT INTO {akismet_spam_marks} (content_type, content_id, spam_created, hostname, mail) VALUES (\'%s\', %d, %d, \'%s\', \'%s\')', $content_type, $content_id, time(), $hostname, $user_mail);

    if (variable_get('akismet_connection_enabled', 1)) {
      akismet_api_cmd_submit_spam(akismet_prepare_comment_data($content_type, $content));
      $action = ($content_type == 'node' ? t('Content submitted as spam') : t('Comment submitted as spam'));
    }
    else {
      $action = ($content_type == 'node' ? t('Content marked as spam') : t('Comment marked as spam'));
    }
  }
  else { // submit-ham
    db_query('DELETE FROM {akismet_spam_marks} WHERE content_type = \'%s\' AND content_id = %d', $content_type, $content_id);

    if (variable_get('akismet_connection_enabled', 1)) {
      akismet_api_cmd_submit_ham(akismet_prepare_comment_data($content_type, $content));
      $action = ($content_type == 'node' ? t('Content submitted as ham') : t('Comment submitted as ham'));
    }
    else {
      $action = ($content_type == 'node' ? t('Content marked as ham') : t('Comment marked as ham'));
    }
  }

  if ($log_action) {
    watchdog('content', t('%action: %title', array('%action' => $action, '%title' => theme('placeholder', $content_title))), WATCHDOG_NOTICE, $content_link);
  }
  akismet_clear_cache();
}

/**
 * Execute content publish/unpublish operations.
 *
 * @param string Content type; it can be 'node' or 'comment'.
 * @param object Content object.
 * @param string Operation; it can be 'publish' or 'unpublish'.
 * @param boolean TRUE to log action (default); FALSE otherwise (ie. the caller logs the action).
 */
function akismet_content_publish_operation($content_type, $content, $op, $log_action = TRUE) {
  if ($content_type == 'node') {
    // This code snippet is based on node.module::node_admin_nodes_submit()
    // Only the node record is updated, no other hooks are invoked.

    // perform the update action.
    db_query('UPDATE {node} SET status = %d WHERE nid = %d', ($op == 'publish' ? 1 : 0), $content->nid);

    if ($log_action) {
      $action = ($op == 'publish' ? t('Content published') : t('Content unpublished'));
      watchdog('content', t('%action: %title', array('%action' => $action, '%title' => theme('placeholder', $content->title))), WATCHDOG_NOTICE, l(t('view'), 'node/'. $content->nid));
    }
  }
  else { // comment
    // This code snippet is based on comment.module::comment_admin_overview_submit()

    // Cache operations in case we need to come here more than once per request.
    static $comment_operations = FALSE;
    if (!$comment_operations) {
      $comment_operations = comment_operations();
    }

    // extract the appropriate database query operation.
    $query = $comment_operations[$op][1];
    // perform the update action, then refresh node statistics.
    db_query($query, $content->cid);

    // Update comment statistics.
    _comment_update_node_statistics($content->nid);
    // Allow modules to respond to the updating of a comment.
    comment_invoke_comment($content, $op);

    if ($log_action) {
      $action = ($op == 'publish' ? t('Comment published') : t('Comment unpublished'));
      watchdog('content', t('%action: %subject', array('%action' => $action, '%subject' => theme('placeholder', $content->subject))), WATCHDOG_NOTICE, l(t('view'), 'node/'. $content->nid, NULL, NULL, 'comment-'. $content->cid));
    }
  }

  akismet_clear_cache();
}

/**
 * Prepare comment data for Akismet requests.
 *
 * @param string 'node' or 'comment'
 * @param object $node or $comment
 * @return array
 */
function akismet_prepare_comment_data($content_type, $content) {
  // Prepare data that is common to nodes/comments.
  $comment_data = array(
    // IP address of the comment submitter.
    'user_ip' => (!empty($content->hostname) ? $content->hostname : $_SERVER['REMOTE_ADDR']),
    // User agent information of the comment submitter.
    'user_agent' => $_SERVER['HTTP_USER_AGENT'],
    // The content of the HTTP_REFERER header should be sent here.
    'referrer' => $_SERVER['HTTP_REFERER'],
    // May be blank, comment, trackback, pingback, or a made up value like "registration".
    'comment_type' => '',
    // Submitted name with the comment.
    'comment_author' => $content->name,
  );

  // Prepare data that varies depending on type of content.
  if ($content_type == 'comment') {
    $comment_data['permalink'] = url('node/'. $content->nid, NULL, 'comment-'. $content->cid, TRUE);
    $comment_data['comment_author_email'] = $content->mail;
    $comment_data['comment_author_url'] = $content->homepage;
    $comment_data['comment_content'] = $content->comment;
  }
  else {
    global $user;
    $comment_data['permalink'] = url('node/'. $content->nid);
    $comment_data['comment_author_email'] = (isset($user->mail) ? $user->mail : '');
    $comment_data['comment_author_url'] = '';
    $comment_data['comment_content'] = $content->body;
  }
  return $comment_data;
}

/************************************************************\
  phpMiX Version Checker
\************************************************************/

/**
 * Check module version.
 *
 * @param boolean FALSE will return a cached value (if exists); otherwise it will perform a real time connection.
 * @return string The latest released module version,
 *                NFND if the server reports "Module Not Found" (something that shouldn't happen) or
 *                an empty string if connection fails (reason logged to watchdog).
 */
function _akismet_check_version($refresh = FALSE) {
  global $base_url;
  $version_string = variable_get('akismet_version_string', FALSE);
  $timestamp_now = time();
  if (!$version_string) {
    $refresh = TRUE;
  }
  else {
    $timestamp_age = variable_get('akismet_version_check_age', 604800);
    if ($timestamp_age > 0) {
      $timestamp_last = variable_get('akismet_version_check_timestamp', 0);
      if (($timestamp_last + $timestamp_age) < $timestamp_now) {
        $refresh = TRUE;
      }
    }
  }
  if ($refresh) {
    $version_url = AKISMET_MODULE_HOMEURL .'/version';
    $result = drupal_http_request($version_url, array('User-Agent' => AKISMET_MODULE_USERAGENT, 'Referer' => $base_url . base_path()));
    if (!isset($result->code) || !in_array($result->code, array(200,302,307)) || empty($result->data)) {
      watchdog('version check', t('Could not check version of akismet module, due to "%error".', array('%error' => theme('placeholder', $result->code .' '. $result->error))), WATCHDOG_ERROR, l(t('check'), $version_url, array('target'=>'_blank'), NULL, NULL, TRUE));
      return '';
    }
    $new_version = trim($result->data);
    if (AKISMET_MODULE_VERSION != $new_version) {
      watchdog('version check', t('New version of akismet module seems to be available. Your currently installed version is <strong>%your-version</strong>. The latest available version is <strong>%new-version</strong>.', array('%your-version' => AKISMET_MODULE_VERSION, '%new-version' => $new_version)), WATCHDOG_WARNING, l(t('module home'), AKISMET_MODULE_HOMEURL, array('target'=>'_blank'), NULL, NULL, TRUE));
    }
    else {
      watchdog('version check', t('Your version of akismet module is up to date.'), WATCHDOG_WARNING, l(t('module home'), AKISMET_MODULE_HOMEURL, array('target'=>'_blank'), NULL, NULL, TRUE));
    }
    $version_string = $new_version;
    variable_set('akismet_version_string', $version_string);
    variable_set('akismet_version_check_timestamp', $timestamp_now);
  }
  return $version_string;
}

/**
 * Get version information message.
 *
 * @param string URL of the current page.
 * @return string
 */
function _akismet_get_version_message($url) {
  $new_version = _akismet_check_version(isset($_GET['vchk']) ? TRUE : FALSE);
  if (empty($new_version)) {
    drupal_set_message(t('Sorry, could not connect to remote server to check for new version information. Please, consult the <a href="%admin-logs">log</a> for details.', array('%admin-logs' => url('admin/logs'))), 'error');
  }
  else {
    if (isset($_GET['vchk'])) {
      drupal_goto($url);
    }
    if ($new_version != AKISMET_MODULE_VERSION) {
      drupal_set_message(t('Your installation does <strong>not</strong> seem to be up to date. Updates are available, please visit the <a href="%module-url" target="_blank">Akismet module home</a> to obtain the latest version. The latest available version is <strong>%new-version</strong>. ', array('%module-url' => AKISMET_MODULE_HOMEURL, '%new-version' => $new_version)), 'error');
    }
  }
  $timestamp_last = variable_get('akismet_version_check_timestamp', 0);
  $output = '<p>'
    .t('You are running version <strong>%your-version</strong>', array('%your-version' => AKISMET_MODULE_VERSION))
    .($timestamp_last > 0 ? ', '. t('version checked %time ago', array('%time' => format_interval(time() - $timestamp_last))) : '')
    .'. '. t('<a href="%check">Check for newest version</a>.', array('%check' => url($url, 'vchk=1')))
    .'</p>';
  return $output;
}

/************************************************************\
  Akismet API implementation
\************************************************************/

/**
 * Akismet API: Key Verification  rest.akismet.com/1.1/verify key
 *
 * @param string WordPress API Key.
 * @return integer See constants AKISMET_API_RESULT_xxx.
 */
function akismet_api_cmd_verify_key($key) {
  global $base_url;
  if (!empty($key)) {
    $request = 'key='. $key .'&blog='. $base_url . base_path();
    $response = _akismet_api_http_post($request, AKISMET_API_HOST, '/'. AKISMET_API_VERSION .'/verify-key');
  }
  return (isset($response[1]) && 'valid' == $response[1] ? AKISMET_API_RESULT_SUCCESS : AKISMET_API_RESULT_ERROR);
}

/**
 * Akismet API: Comment Check  api-key.rest.akismet.com/1.1/comment-check
 *
 * @param array Comment data; see function akismet_prepare_comment_data().
 * @return integer See constants AKISMET_API_RESULT_xxx.
 */
function akismet_api_cmd_comment_check($comment_data) {
  if (!variable_get('akismet_connection_enabled', 1)) {
    return AKISMET_API_RESULT_ERROR;
  }
  $akismet_wpapikey = variable_get('akismet_wpapikey', '');
  if (!empty($akismet_wpapikey)) {
    $comment_data = array_merge(_akismet_api_prepare_request_data(), $comment_data);
    $query_string = _akismet_api_build_query_string($comment_data);
    $host = $akismet_wpapikey .'.'. AKISMET_API_HOST;
    $response = _akismet_api_http_post($query_string, $host, '/'. AKISMET_API_VERSION .'/comment-check');
  }
  if (!isset($response[1])) {
    return AKISMET_API_RESULT_ERROR;
  }
  return ('true' == $response[1] ? AKISMET_API_RESULT_IS_SPAM : AKISMET_API_RESULT_IS_HAM);
}

/**
 * Akismet API: Submit Spam  api-key.rest.akismet.com/1.1/submit-spam
 *
 * @param array Comment data; see function akismet_prepare_comment_data().
 * @return integer See constants AKISMET_API_RESULT_xxx.
 */
function akismet_api_cmd_submit_spam($comment_data) {
  if (!variable_get('akismet_connection_enabled', 1)) {
    return AKISMET_API_RESULT_ERROR;
  }
  $akismet_wpapikey = variable_get('akismet_wpapikey', '');
  if (!empty($akismet_wpapikey)) {
    $query_string = _akismet_api_build_query_string($comment_data);
    $host = $akismet_wpapikey .'.'. AKISMET_API_HOST;
    $response = _akismet_api_http_post($query_string, $host, '/'. AKISMET_API_VERSION .'/submit-spam');
  }
  return (isset($response[1]) ? AKISMET_API_RESULT_SUCCESS : AKISMET_API_RESULT_ERROR);
}

/**
 * Akismet API: Submit Ham  api-key.rest.akismet.com/1.1/submit-ham
 *
 * @param array Comment data; see function akismet_prepare_comment_data().
 * @return integer See constants AKISMET_API_RESULT_xxx.
 */
function akismet_api_cmd_submit_ham($comment_data) {
  if (!variable_get('akismet_connection_enabled', 1)) {
    return AKISMET_API_RESULT_ERROR;
  }
  $akismet_wpapikey = variable_get('akismet_wpapikey', '');
  if (!empty($akismet_wpapikey)) {
    $query_string = _akismet_api_build_query_string($comment_data);
    $host = $akismet_wpapikey .'.'. AKISMET_API_HOST;
    $response = _akismet_api_http_post($query_string, $host, '/'. AKISMET_API_VERSION .'/submit-ham');
  }
  return (isset($response[1]) ? AKISMET_API_RESULT_SUCCESS : AKISMET_API_RESULT_ERROR);
}

/**
 * Prepare user request data for Akismet requests.
 *
 * @return array Relevant information extracted from $_SERVER superglobal.
 */
function _akismet_api_prepare_request_data() {
  // You may add more elements here, but they are often related to internal server
  // data that makes little sense to check whether a comment is spam or not.
  // Be sure to not send HTTP_COOKIE as it may compromise your user's privacy!
  static $safe_to_send = array(
    'CONTENT_LENGTH',
    'CONTENT_TYPE',
    'HTTP_ACCEPT',
    'HTTP_ACCEPT_CHARSET',
    'HTTP_ACCEPT_ENCODING',
    'HTTP_ACCEPT_LANGUAGE',
    'HTTP_REFERER',
    'HTTP_USER_AGENT',
    'REMOTE_ADDR',
    'REMOTE_PORT',
    'SCRIPT_URI',
    'SCRIPT_URL',
    'SERVER_ADDR',
    'SERVER_NAME',
    'REQUEST_METHOD',
    'REQUEST_URI',
    'SCRIPT_NAME'
  );

  // The contents of $_SERVER doesn't change between requests,
  // so we can have this cached in static storage.
  static $server_data;
  if (!$server_data) {
    $server_data = array();
    foreach ($_SERVER as $key => $value) {
      if (in_array($key, $safe_to_send)) {
        $server_data[$key] = $value;
      }
    }
  }
  return $server_data;
}

/**
 * Build query string for Akismet request.
 *
 * @param array
 * @return string
 */
function _akismet_api_build_query_string($array) {
  global $base_url;
  $string = 'blog='. $base_url . base_path();
  foreach ($array as $key => $value) {
    $string .= '&' . $key . '=' . urlencode(stripslashes($value));
  }
  return $string;
}

/**
 * Perform a HTTP POST request against the akismet server.
 *
 * @param string The request.
 * @param string The akismet host, prefixed with the API key (except when checking for the key itself).
 * @param string The path where to perform the request.
 * @return array Headers in $response[0] and entity in $response[1].
 */
function _akismet_api_http_post($request, $host, $path) {
  $fsock_timeout = (int)variable_get('akismet_connection_timeout', 10);

  $http_request = "POST $path HTTP/1.0\r\n"
    ."Host: $host\r\n"
    ."Content-Type: application/x-www-form-urlencoded; charset=utf-8\r\n"
    .'Content-Length: '. strlen($request) ."\r\n"
    .'User-Agent: '. AKISMET_API_USERAGENT ."\r\n"
    ."\r\n"
    .$request;

  $response = '';
  if (false !== ($fs = @fsockopen($host, AKISMET_API_PORT, $errno, $errstr, $fsock_timeout))) {
    fwrite($fs, $http_request);
    while (!feof($fs)) {
      $response .= fgets($fs, 1160); // One TCP-IP packet
    }
    fclose($fs);
    $response = explode("\r\n\r\n", $response, 2);
  }
  return $response;
}
